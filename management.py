from socket import *
import threading
import argparse # for command line parsing
import logging
##import time
#import statistics # for computing mean
import csv

class Task: pass

tasks = []
num_of_nodes = 1
threads = []
finished_tasks = 0
lock = threading.Lock()
def milliseconds(seconds):
    # convert seconds to milliseconds
    return seconds * 1000

def parse_args():
    # command for parsing command line arguments

    # create parser
    parser = argparse.ArgumentParser()

    # add arguments to the parser
    parser.add_argument("server_port")
    parser.add_argument("hashed_pw") # hashed pw
    parser.add_argument("num_nodes") # number of worker nodes used to crack

    # parse the arguments
    args = parser.parse_args()
    logging.info(args)

    return int(args.server_port), args.hashed_pw, int(args.num_nodes)

def tcp_setup(server_port):
    # Set up connection with the server
    server_socket = socket(AF_INET, SOCK_STREAM)
    server_socket.bind(('localhost', server_port))
    #logging.info("[TCP Setup] Client connection attempted")
    server_socket.listen(10)
    return server_socket

# mt is measurement type
# rows is the data rows generated by measurement phase
def write_data_to_csv(mt, rows):
    # write tput or rtt data to csv
    with open(mt + '.csv', 'w') as f:
        headers = [["size", "mean"]]
        write = csv.writer(f)
        write.writerows(headers)
        write.writerows(rows)


#function that is passed to thread to handle clients
def client_handler(client_socket, addr):
    global lock
    global num_of_nodes
    global tasks
    global finished_tasks
    response = client_socket.recv(1024).decode()
    if response == "FrontEnd":
        client_socket.send("Please input number of nodes to split work".encode())
        lock.acquire()
        num_of_nodes = int(client_socket.recv(1024).decode())
        lock.release()
        while(True):
            hashed_pw = client_socket.recv(1024).decode()
            task = Task()
            task.hash = hashed_pw
            task.seq = 1
            task.finished = False
            lock.acquire()
            tasks.append(task)
            lock.release()
    else:
        while(True):
            lock.acquire()
            if finished_tasks < len(tasks):
                client_socket.send((str(finished_tasks) + str(num_of_nodes) + str(tasks[finished_tasks].seq) + tasks[finished_tasks].hash).encode())
                if tasks[finished_tasks].seq < num_of_nodes:
                    tasks[finished_tasks].seq += 1
                else:
                    tasks[finished_tasks].finished = True
                    finished_tasks += 1
                lock.release()
                response = client_socket.recv(1024).decode()
                lock.acquire()
                if response != "fail":
                    if tasks[int(response[0])].finished == False:
                        print("Found string:", response[1:])
                        tasks[int(response[0])].finished = True
                lock.release()
            else:
                lock.release()
    

                






def main():
    logging.basicConfig(format='%(asctime)s %(message)s', level=logging.INFO) # logging configuration
    TPUT_MSG_SIZE = 1
    buffer_size = TPUT_MSG_SIZE + 10000

    server_port, hashed_pw, num_nodes = parse_args()
    
    server_socket = tcp_setup(server_port)
    
    for i in range(5):
        connection_socket, addr = server_socket.accept()
        logging.info("New client (" + str(addr) + ") attached")
        thread_a =threading.Thread(target=client_handler, args=(connection_socket,addr))
        threads.append(thread_a)
        thread_a.start()
        
    server_socket.close()
    logging.info("Connection closed")

    # TODO: manager logic

if __name__ == "__main__":
    main()
